# Module 4: Encapsulation and Inheritance

## Lesson: Abstract Classes and Interfaces

### Object-Oriented Programming Recap

Before we dive into abstract classes and interfaces, let's do a quick recap of object-oriented programming (OOP) concepts.

In OOP, we create classes to represent objects in our code. Each class defines properties (attributes) and methods (behaviors) for the objects it represents. Objects are created from the class, and each object has its own set of values for the properties defined in the class.

Inheritance is another OOP concept that allows us to create new classes based on existing classes. The new class inherits the properties and behaviors of the existing class, and can also add or modify properties and behaviors as needed.

Encapsulation is the practice of hiding implementation details within a class. We can use access modifiers (public, private, protected) to control which parts of a class are visible and modifiable from outside the class.

### Abstract Classes

Abstract classes are classes that cannot be instantiated on their own, but instead are meant to be extended by other classes. They often contain abstract methods, which are methods without implementations. Abstract methods define a method signature without actually providing the code to execute the method.

To create an abstract class in Java, we use the `abstract` keyword in the class declaration. Here's an example:

```java
abstract class Shape {
  int x, y;

  Shape(int x, int y) {
    this.x = x;
    this.y = y;
  }

  abstract double area();
}
```

Here, we've defined an abstract `Shape` class with an `area` method that has no implementation. When we extend this class, we must provide an implementation for the `area` method, otherwise the subclass will also be forced to declare as abstract.

### Interfaces

Interfaces are similar to abstract classes, but instead of defining properties and some of them abstract methods they only define method signature to be implemented in other classes and they can not have implementation of the defined method. Interfaces are often used to define a set of behaviors that a class should implement. Interfaces allow us to provide a common contract of behavior to multiple classes.

To create an interface in Java, we use the `interface` keyword, and all the methods in the interface implicitly declare abstract. Here is an example of an interface:

```java
interface Drawable {
  void draw();
  void resize(int width, int height);
}
```

Here, we've defined an interface called `Drawable`, which has two methods `draw` and `resize` with no implementations. Any class that implements this interface must provide an implementation of these methods.

### Abstract Classes vs Interfaces

So how do we decide whether to use an abstract class or an interface? Here are some general guidelines:

- Abstract classes are useful when we want to define a base class with some common functionality that will be shared by multiple subclasses.
- Interfaces are useful when we want to define a contract of behavior that should be implemented by multiple classes, regardless of their inheritance tree.
- A class can implement multiple interfaces, but can only inherit from one class (abstract or concrete).
- Abstract classes can have implemented methods, which can be inherited by subclasses. Interfaces cannot define implemented methods.
- Abstract classes can have access modifiers on their properties/methods, while Interfaces can only have public properties/method signatures.

### Example

Let's take an example to see how we can use abstract classes and interfaces together in a single system. Suppose we're building a shape-drawing application. We might have an abstract `Shape` class, with subclasses like `Circle`, `Square`, and `Rectangle` that provide an implementation for the `area` method.

We could also have an `Editable` interface that defines a set of methods like `rotate` and `move`. Our `Shape` subclasses could implement this `Editable` interface to add editing functionality to each shape subclass.

```java
abstract class Shape {
  int x, y;

  Shape(int x, int y) {
    this.x = x;
    this.y = y;
  }

  abstract double area();
}

interface Editable {
  void rotate(double angle);
  void move(double x, double y);
}

class Circle extends Shape implements Editable {
  double radius;

  Circle(int x, int y, double radius) {
    super(x, y);
    this.radius = radius;
  }

  double area() {
    return Math.PI * Math.pow(radius, 2);
  }

  void rotate(double angle) {
    // implementation
  }

  void move(double x, double y) {
    // implementation
  }
}
```

In this example, our `Circle` class extends `Shape` and implements `Editable`. It provides an implementation for the `area` method defined in `Shape`, as well as implementations for the `rotate` and `move` methods defined in `Editable`.

## Conclusion

In this lesson, we learned about abstract classes and interfaces, which allow us to create extensible and adaptable code through polymorphism. We learned the difference between abstract classes and interfaces and how to use them together in a single system. We also saw how they can be used to make a system more flexible and maintainable.