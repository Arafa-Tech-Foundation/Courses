# Module 4: Encapsulation and Inheritance

## Lesson 3: Polymorphism

Welcome to the third lesson of Module 4: Encapsulation and Inheritance. In this lesson, we will learn about polymorphism, one of the fundamental concepts in Object Oriented Programming (OOP). 

### What is Polymorphism?

Polymorphism is the ability of an object to take many forms. In OOP, polymorphism allows objects of different classes to be treated as if they were objects of the same class. This means that a method in a superclass can be defined as a generic method, and then overridden in a subclass to provide a specific implementation.

### Types of Polymorphism

There are two types of polymorphism: compile-time polymorphism and runtime polymorphism.

#### Compile-time Polymorphism

Compile-time polymorphism, also known as method overloading, allows methods with the same name but different parameters to be defined in a class. The correct method to call is determined at compile-time based on the number and type of arguments passed to the method. Here is an example:

```java
public class MathUtils {
    public static int add(int x, int y) {
        return x + y;
    }
    
    public static double add(double x, double y) {
        return x + y;
    }
    
    public static double add(int x, double y) {
        return x + y;
    }
}
```

In this example, we have three versions of the `add` method that take different types and numbers of arguments. The correct version of the method is selected at compile-time based on the types and numbers of the arguments passed to it.

#### Runtime Polymorphism

Runtime polymorphism, also known as method overriding, allows methods in a subclass to override methods in its superclass. When a method is called on an object, the actual implementation that is executed is determined at runtime based on the type of the object. Here is an example:

```java
public class Animal {
    public void eat() {
        System.out.println("The animal is eating.");
    }
}

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("The dog is eating.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Animal dog = new Dog();
        
        animal.eat(); // prints "The animal is eating."
        dog.eat(); // prints "The dog is eating."
    }
}
```

In this example, we have a superclass `Animal` with a method `eat`, and a subclass `Dog` that overrides the `eat` method to provide its own implementation. We create two objects, one of type `Animal` and one of type `Dog`, and call the `eat` method on both of them. The actual implementation of `eat` that is executed is determined at runtime based on the type of the object.

### Benefits of Polymorphism

The main benefit of polymorphism is that it allows us to write flexible and reusable code. By treating objects of different classes as if they were objects of the same class, we can write generic classes and methods that can be used with a variety of different objects. This reduces redundancy and makes our code more extensible and easier to maintain.

### Conclusion

In this lesson, we learned about polymorphism, one of the fundamental concepts in Object Oriented Programming. We discussed the two types of polymorphism, compile-time polymorphism and runtime polymorphism, and the benefits of using polymorphism in our code. For more information about polymorphism, be sure to check out the Java documentation and other OOP resources.